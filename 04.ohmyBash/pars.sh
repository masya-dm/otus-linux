#!/bin/bash

source $HOME/.bashrc			#Загрузка переменных из файла

f=`find /root/tools/ -type f -name '*.log'`  				# Переменной f присваивается результат выполнения поиска в текущей директории файлов с маской *.log.  
									# Всё поламается если будет несколько файлов в результате поиска. Для устранения этого мождно использовать параметр mtime, изменнёных за последние 24 часа.
n_st=`wc -l $f | awk {'print $1'}`; 					# Пременной n_st присваивается результат подсчёта количества строк в файле, awk выводит только первый столбец.
res=./mail.txt								# Временный файл для сбора отчёта. После отправки письма удаляется.

function X_ips {
ips=();						      # Массив для несортированных ip адресов
uni=();						      # Массив для сортированных ip адресов
a=`sed -n ''$n_st_l','$n_st''p $f | awk {'print $1'}` # sed выводит строки с первой,если первый запуск скрипта, и до подсчитаной в переменной n_st, awk обрезает первый столбец, результат помещается в перменную а, там они живут большой строкой.
for i in echo $a ;  do ips+=($i); done;		      # Заполнение массива ips в цикле. Если попросить echo $a, то большая строка переменной a побьётся по пробелу на строки и их можно будет в цикле записать в массив. 					
					              # Запись ips+=($i) говорит о том что при каждоой новой строке из $a добавлять новый элемент массива. хоетл было сделать это в одну строку, без выделения переменной a,
					              # но потратил много времении и не заборол таки историю с экранированием параметров у sed.
uni=($(printf "%s\n" "${ips[@]}" | sort | uniq -c | sort -rn| head -n "$1";)) # С помощью команды printf выводятся все элементы массива, разделённые переходом на новую строку \n, список сортируется, вычитываются уникальные значения и 
									      # количество их повторений, опять сортируется в обратном порядке - первым станем с наибольшим число повторений и head выводит только указанное при запуске
									      # количество ip адресов. В получившемся масиве данные живут в виде (колличество_повторений ip-адрес).
echo -e " \n	Top "$1" IP\n  "  >> $res; #Добавляет в файл отчёта две новые строки, а между ними Top указанных в параметре скрипта адресов. 
printf "|%s|%s\n--------------------\n" ${uni[@]} >> $res; # ptintf говорит как выводить данные из массива, первая %s это количество повторений, вторая %s эта ip-адрес. Между так называемы элементы таблицы.
							   # Всю эту историю с массивами я затеял чтоб попробовать порисовать таблички с результатами выборок. Вышло так себе, а времени ушло капец. 
							   # Если тот же набор sort, uniq и head применить просто к указанному столбцу, то тоже отсортирует, но хотелось таблички. 
}

function Y_url {
ips=();
uni=();
a=`sed -n ''$n_st_l','$n_st''p $f | awk {'print $11'}`  #Здесь всё тоже самое, но для столбца номер 11 из лог файла.
for i in echo $a ;  do ips+=($i); done;
uni=($(printf "%s\n" "${ips[@]}" | sort | uniq -c | sort -rn| head -n "$1";)) # head тоже берёт $1 параметр, но тут счёт идёт по количеству параметров переданных функции.
echo -e " \n	Top "$1" URL\n  "  >> $res;
printf "|%s|%s\n--------------------\n" ${uni[@]} >> $res;
}
 
function A_code {
    ips=();
    uni=();
    a=`sed -n ''$n_st_l','$n_st''p $f | awk {'print $9'}` # Для 9-го столбца.
    for i in echo $a ;  do ips+=($i); done;
    uni=($(printf "%s\n" "${ips[@]}" | sort | uniq -c | sort -rn;))
    echo -e " \n	All Answer Code\n  "  >> $res;
    printf "|%s|%s\n--------------------\n" ${uni[@]} >> $res;
}

function Err_4 {
    echo -e " \n	All Error\n   "  >> $res;
    sed -n ''$n_st_l','$n_st''p $f | grep -e "404" >> $res # Поиск строк содержащих ошибку 404.
}

function stat_d {
    D1=`sed -n "$n_st_l"p $f |awk {'print $4'} | sed -e 's/.//' -e 's/\// /' -e 's/\// /' -e 's/\// /' -e 's/:/ /'` # Форматирование даты начала обрабатываемого периода, для вставки в отчет. sed удаляет певый символ строки и убирает / 
    D2=`sed -n "$n_st"p $f |awk {'print $4'} | sed -e 's/.//' -e 's/\// /' -e 's/\// /' -e 's/\// /' -e 's/:/ /'`   # тоже для последней строки. 
    echo -e "====$D1 - $D2====\n " > $res;
}

function nt_do {
    echo "Нет изменений с последенего запука скрипта"  | mail -s "Статистика" -r nginx@$HOSTNAME $1; #Отправка сообщения о том что нет данных для обработки скриптом.
}

function nt_bl {
  echo "Защита от мультизапуска сработала"  | mail -s "Статистика" -r nginx@$HOSTNAME $1;  #Отправка сообщения о срабатывании блоировки.
}

function s_mail {
    cat $res  | mail -s "Статистика" -r nginx@$HOSTNAME $1
    rm -rf $res
}

function ins_v {
    sed -i '/f_l=/d' $HOME/.bashrc;		# sed по образцу f_l удаляет строку
    sed -i '/n_st_l=/d' $HOME/.bashrc;		# sed по образцу n_st_l удаляет строку
    echo "n_st_l=$n_st_l" >> $HOME/.bashrc;	# записывает в конец файла последнее значение количества строк в обработаном файле
    echo "f_l=$f_l" >> $HOME/.bashrc;		# записывает в конец файла имя послденего обработанного файла
}

if [ -f ./lockfile ];  # Проверка есть ли lockfile
    then nf_bl $3;	# если есть то вызвать функцию nt_bl и передать ей параметр номер 3.
else

if [ -z $1 ]; 					# Проверка наличия входных параметров.
    then echo "Не задан первый параметр";	# $1 - количество ip адресов с наибольшим количеством запросов, 10 - первые 10 и тд.
elif [ -z $2 ]; 				# $2 - количество запрашиваемых адресов. 5 - первые 5. 
    then echo "Не задан второй параметр";	# $3 - email оправлять отчёт.
elif [ -z $3 ];					
    then echo "Не задан третий параметр";	
else

if [ -z "$n_st_l" ];				# Проверяет пуста ли переменная n_st_l, это число строк в файле с момента последнего запуска. В конце блока пишем в файл $HOME/.bashrc.
    then					# Если пуста, то с файлом ещё не работали и значит нужно начальной строкой считать первую и конечной ту которая в переменной n_st.
    echo $$ > lockfile;				# Вывод номера процесса в lockfile;
    n_st_l=1;					# Присвоение значния первой строки.
    stat_d;					# Вызов функции для формирования заголовка обрабатываемого временного интервала.
    X_ips $1;					# Вызов функции для подсчёта ip адресов с наибольшим количеством запросов.
    Y_url $2;					# Вызов функции для подсчёта наиболее часто спрашиваемых url.
    A_code;					# Подсчёт всех кодов ответа.
    Err_4;					# Подсчёт всех ошибок.
    n_st_l=$n_st; echo "n_st_l=$n_st_l" >> $HOME/.bashrc; # Присвоение переменной содержащей значение последней обработанной номера последней обработанной строки и запись её в .bashrc
    f_l=$f; echo "f_l=$f_l" >> $HOME/.bashrc;	# Присвоение переменной имени файла, значения последнего обрабатываемого файла и запись её в .bashrc
    s_mail $3;					# Вызов функции для отправки письма с отчётом на email из $3.
    rm -rf lockfile;				# Удаление файла блокировки.
elif [ "$f" != "$f_l" ];			# Если переменная n_st_l из прошлого блока не пуста, то сравниваем переменные содержащих имя файла. Если не равны то считаем что это уже другой новый файл и его нужно обрабатывать с 1-ой строки.
    then					# Далее всё тоже самое что и в предыдущем блоке.
    echo $$ > lockfile;
    n_st_l=1;
    stat_d;
    X_ips $1;
    Y_url $2;
    A_code;
    Err_4;
    n_st_l=$n_st;
    f_l=$f;
    ins_v;	# функция записи новых переменны в bashrc, находит по шаблону старые значения, удаляет и пишет новые.
    s_mail $3;
    rm -rf lockfile;
elif [ $n_st_l -eq $n_st ];			# Если переменная имя файла из прошлого блока не изменилась, то надо проверить число строк, если оно с момента последнего запуска не изменилось то отправляем письмо о таком положении дел.
    then 
    echo $$ > lockfile;
    nt_do $3;					# Функция отправки сообщения о том что с момента прошло запуска скрипта нет изиенений в файле.
    rm -rf lockfile;
else						# Если число строк не равно то обрабатываем с последней обработаной строки и до конца.
    echo $$ > lockfile;
    stat_d;
    X_ips $1;
    Y_url $2;
    A_code;
    Err_4;
    n_st_l=$n_st;
    f_l=$f;
    ins_v;
    s_mail $3;
    rm -rf lockfile;
fi;
fi;
fi;